# 불필요한 Effect를 제거하는 방법

## Effect가 필요하지 않은 경우
- 렌더링을 위해 데이터를 변환하는 경우
- 사용자 이벤트 처리하는 경우

<br/>외부 시스템과 동기화하려면 Effect가 필요

<br/>중복 업데이트를 피해라.

계산할 수 있는 것이 있으면 state에 넣지 말 것. 렌더링 중에 계산하라.

<br/>
고비용 계산을 useMemo 훅으로 감싸서 캐시해라.
useMemo로 감싼 함수는 렌더링 중에 실행되므로, 순수 계산에만 작동한다.

<br/>
고비용인지 어떻게 알까?
console.time, console.timeEnd로 찍어보자.


useMemo는 첫 렌더링을 빠르게 하진 않고, 업데이트 시 불필요한 작업을 건너뛰는 데 도움을 준다.

CPU 쓰로틀링을 통해 테스트해보는 것도 좋은 방법.

<br/>

# prop이 변할 때 모든 state 리셋하기

명시적인 key를 전달해서, 각 사용자가 다른 사용자라는 걸 React에 알려라.

다른 key를 보내면 별개의 컴포넌트로 취급함. -> key 변경될 때마다 DOM 재생성 및 state 재설정할 거임.

<br/>

# prop이 변할 때 일부 state 조정하기

렌더링 중에 직접 state를 조정해라.

렌더링 도중 컴포넌트를 업데이트하면, 
반환된 JSX를 버리고 렌더링 즉시 재시도함.
이 때 무한으로 리렌더링 반복하는 걸 막기 위해 items !== prevItems와 같은 조건이 필요하다.
<br/>
이 패턴은 Effect보단 나은데, 대부분의 경우 필요하지 않다. 
가능하면 key로 재설정하거나, 렌더링 중에 모조리 계산하자.

<br/>

# 이벤트 핸들러 간 로직 공유 

Effect 내부에 특정 이벤트에 대한 로직을 넣지 말자.
<br/>
공유 로직을 각 이벤트 핸들러에서 호출해라.

<br/>

# POST요청 보내기 

마찬가지로 이벤트 핸들러에 넣어라.

<br/>

# 연쇄적 계산

가능한 렌더링 중에 계산하고 이벤트 핸들러에서 state를 조정해라.

<br/>

# 애플리케이션 초기화하기 

이미 실행되었는지 여부를 추적해서 실행 안됐을 때 한번만 실행되게 조건문 추가해라.

아니면, 모듈 초기화 중 또는 앱 렌더링 전에 실행할 수도 있다.

<br/>

# state변경을 부모 컴포넌트에 알리기

Effect 대신 이벤트 핸들러 내에서 state 업데이트 하자.

<br/>

# 부모에게 데이터 전달하기 

자식이 부모 state 업데이트하지 말고, 부모 컴포넌트가 데이터 페치해서 자식에게 전달하도록 해라.

<br/>

# 외부 스토어 구독하기 

useSyncExternalStore를 호출해서 외부 저장소 구독해라.

<br/>

# 데이터 페칭하기

클린업 없이 fetch 하지 말 것.
<br/> stale 응답을 무시하기 위해 클린업 함수를 추가하자.
<br/>
기능을 커스텀 훅으로 추출할 수 있는지 잘 살펴보자.

<br/>

# 요약

- 렌더링 중 계산하면 Effect 안 써도 됨
- 고비용 계산 캐시 -> useMemo
- 전체 컴포넌트 트리의 state를 재설정하려면 다른 key 전달
- prop 변경 -> 특정 state 일부를 조정하려면 렌더링 중에 설정
- 컴포넌트가 표시될 때 실행되어야 하는 코드는 Effect에 넣고, 나머지는 이벤트에 넣자.
- 여러 컴포넌트의 state를 업데이트할 때 단일 이벤트에서 처리하는 것이 좋다.
- 여러 컴포넌트에서 state 변수를 동기화할 때 state lifting ㄱㄱ
- Effect로 데이터 페치할 때, 경쟁 조건 피하기 위해 클린업 하자.