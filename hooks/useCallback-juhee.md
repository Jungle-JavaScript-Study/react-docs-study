# 1. Reference

useCallback으로 리렌더링 간에 함수의 정의를 캐싱할 수 있다.
이것도 훅이니까 컴포넌트의 최상위 레벨에서 쓰면 된다!

## Parameters
#### fn
- 캐시하려는 함수를 지정한다.

#### dependencies
- 함수 코드 내부에서 참조되는 모든 반응형 값들의 배열이다.
- 반응형 값에는 props, state, 컴포넌트 내에 직접 선언된 모든 변수와 함수가 포함된다.

## Returns
- 초기 렌더링에서 인자로 받은 함수 fn을 반환한다.
- 이후의 렌더링 동안에는, 의존성이 변경되지 않았다면, 이전 렌더링에서 사용된 동일한 함수 인스턴스를 재사용하여 반환한다. 
- 이후의 렌더링 동안 의존성이 변경되었다면 새로운 함수 인스턴스를 생성하여 반환한다.

## 주의사항
- useCallback은 훅이므로, 컴포넌트의 최상위 레벨이나 자체 훅에서만 호출할 수 있다.
- 특별한 이유가 없다면 캐시된 함수를 버리지 않는다. 

### 캐시를 버리는 경우
- 개발 중에 컴포넌트 파일을 편집할 때 캐시를 버린다.
- 개발 모드와 프로덕션 모두에서 컴포넌트가 초기 마운트 중에 일시 중단되면 캐시를 버린다.

- 미래에, React에 캐시를 버리는 것을 활용하는 더 많은 기능이 추가될 수 있다.
예를 들어, React가 가상화된 목록에 대한 빌트인 지원을 추가한다면, 가상 테이블 뷰포트에서 스크롤되어 벗어난 항목들에 대한 캐시는 버리는 것이 합리적일 것이다.
성능 최적화를 위해 useCallback에 의존하는 경우 이는 사용자의 기대와 일치할 것이다.
그렇지 않은 경우에는, 상태 변수나 ref가 더 적합할 수 있다.


# 2. Usage
## 리렌더링 Skip
- 렌더링 성능을 최적화할 때 자식 컴포넌트에 전달하는 함수를 캐시해야 하는 경우가 있다.
- 리렌더링 사이에 함수를 캐시하려면 함수의 정의를 useCallback으로 감싸면 된다.

useCallback이 언제 유용한지 예시를 통해 보자!
ProductPage에서 ShippingForm 컴포넌트로 handleSubmit 함수를 전달한다고 가정해보자.

```jsx
function ProductPage({ productId, referrer, theme }) {
  // ...
  return (
    <div className={theme}>
      <ShippingForm onSubmit={handleSubmit} />
    </div>
  );
```

여기서 ShippingForm을 최적화해보자.

기본적으로 컴포넌트가 리렌더링되면 React는 모든 바시




# 3. Troubleshooting
